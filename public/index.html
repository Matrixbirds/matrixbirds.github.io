<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>哈库马拉塔塔</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一只热爱二次元, 热爱coding的段子手">
<meta property="og:type" content="website">
<meta property="og:title" content="哈库马拉塔塔">
<meta property="og:url" content="http://matrixbirds.github.io/index.html">
<meta property="og:site_name" content="哈库马拉塔塔">
<meta property="og:description" content="一只热爱二次元, 热爱coding的段子手">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="哈库马拉塔塔">
<meta name="twitter:description" content="一只热爱二次元, 热爱coding的段子手">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="undefined" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Matrixbirds</a></h1>
		</hgroup>

		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Matrixbirds</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="undefined" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Matrixbirds</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-2015年终总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/24/2015年终总结/" class="article-date">
  	<time datetime="2015-12-24T11:52:34.000Z" itemprop="datePublished">2015-12-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/24/2015年终总结/">2015年终总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>日记</li>
<li>TodoList</li>
<li>年终总结</li>
</ul>
<hr>
<h4 id="2015_12/24">2015 12/24</h4><p>  感叹，时间流逝的真快。感觉什么都是刚计划好，感觉什么都没有完成好，感觉到紧张、焦虑。(x_x)</p>
<h4 id="年底了。">年底了。</h4><p>  2015<br>  这一年。我<br>  多了很多眼界，少了很多浮躁，多了很多烦恼，自然也少了很多联系。……%&amp;%&amp;……balabala  </p>
<h4 id="这一年我所做的事情：">这一年我所做的事情：</h4><p>  加入了暴漫（这是我第一家互联网公司，也是第一家给我带来很多帮助的公司。）<br>  来到上海（从来没有想过会去上海工作。）<br>  年终总结</p>
<h4 id="这一年发生的大事件">这一年发生的大事件</h4><p>  我:<br>    加入暴漫:<br>      和曹尼玛一起工作: /因为觉得和自己有一些共同点，真心的爱好技术，热爱新技术，喜欢<code>JavaScript</code>。哈哈对没错<code>JavaScript</code>才是重点/<br>      学会了Ruby: /在team code review下 代码终于ruby了。虽然我知道自己还是半吊子 啦啦啦，路漫漫其修远兮/<br>      拥抱开源社区: /以前觉得，部署一个开源项目是多么困难的事情，开始加入一个项目更加是一件困难的事情/<br>        给cnodejs贡献了一丢丢代码:<br>        给ruby-china贡献了一丢丢代码:<br>        给ruby修正了文档:<br>      收到一份国外remote邀请的面试邮件:<br>        /说实在的，我第一次收到这种邮件，挺兴奋的，我拒绝了，我并不后悔，因为知道自己本身还有很多不足/<br>      开始了ruby圈:<br>        /参加过几次ruby tuesday，在魔都ruby tuesday还是十分的活跃的，rubyist都十分的有国际视野。/<br>      学会了写前端:<br>        可以独自造轮子了。哇咔咔<br>      学会了评估一个任务的工作量:<br>      学会了一丢丢运营tips: /在知乎上以匿名身份自问自答，get到了200+的赞/<br>      参加了技术沙龙:<br>        /1号店的技术总监，黄哲铿给我留下了深刻的影响，还有缘参加了他的读书会，可惜太内向= =一个人都没聊上我就走了/<br>        /七牛的李道兵，学会了如何设计和架构，如何让你的网站能够规模化/<br>        /tinyfool，ios业内鸡汤王+段子手，不过tinyfool的演讲我很喜欢，因为很适合我这种就靠着鸡汤过日子，靠着打鸡血为生的人/<br>      <code>Side Project</code>: /曹尼玛总是说，一定要有<code>idea</code>，一定要去、做<code>Side Project</code>/<br>        做什么肯定是自己喜欢、感兴趣的东西才会更有动力，更有激情。<br>        新技术公司不敢用?<code>Side Project</code>是对新技术最好的评估、和享受的机会<br>        <code>Idea</code>，任你实现<br>        没有<code>deadline</code><br>        <code>Happy^_^</code><br>      支持正版软件:<br>        /<code>Dash</code> 一个文档大全，有主流语言和框架的文档资源/<br>      学习如何在Mac上工作<br>      学会了玩转pipe line<br>    …….</p>
<h4 id="这一年让我深刻的书">这一年让我深刻的书</h4><p>  《Refactoring Improving the Design of Existing Code》</p>
<pre><code><span class="bullet">* </span>真是劲爆到屌爆的重构书。
</code></pre><p>  《Ruby Meta Programming 2th》</p>
<pre><code><span class="bullet">* </span>ruby TM 还可以这么玩?
</code></pre><p>  《代码大全》</p>
<pre><code><span class="bullet">* </span>非常之多的rules
</code></pre><p>  《七周七并发模型》</p>
<pre><code><span class="bullet">* </span>原来并发模型是这样子的啊。有这么多方案可以搞定它
</code></pre><p>  《JavaScript忍者秘籍》</p>
<pre><code>* 这本书十分的喜欢，开篇介绍了不少FP <span class="keyword">in</span> JavaScript，作者是徐涛，<span class="keyword">js</span>界大牛之一。也是我常去光顾的技术博客之一
</code></pre><p>  《全栈工程师的自我修养》</p>
<pre><code><span class="bullet">* </span>作者是腾讯QQ空间的资深全栈工程师。书里提到了很多价值观的东西，程序员不应当只会冷漠的写代码，更多的是要学会如何发掘一个东西的价值，并且围绕如何最大化它的价值来做决策和实现。
</code></pre><h4 id="致新的一年的自己">致新的一年的自己</h4><p>  拥有一个自己的网站:<br>    <code>Side Project</code>:<br>      抄一个<code>bilibili</code>(x捂脸 /w/ 理由：就是喜欢，就是这么任性)  </p>
<p>  [拿出12年那时候的热情。]</p>
<ul>
<li>坚持写博客。不眼高手低，总结每次踩的坑。</li>
<li>学几门新语言PHP7，Haskell，Clojure（这只是为了多一点<code>idea</code>)</li>
<li>温习基础算法和基础数据结构</li>
<li>坚持刷LeetCode</li>
<li>多折腾Linux</li>
<li><p>在Stackoverflow刷脸</p>
<p>多和别人交流。</p>
<ul>
<li>学会主动的勾搭陌生人</li>
<li>参加线下活动的时候不要害羞。</li>
</ul>
<p>坚持自己做饭和买菜。提高文学修养。<br>坚持每天听podcast，追一些生肉美剧。提高自己的英语听力水平。</p>
</li>
</ul>
<h4 id="最后。">最后。</h4><p>  Stay Foolish, Stay Hungry。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-重拾算法计划" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/30/重拾算法计划/" class="article-date">
  	<time datetime="2015-09-30T06:34:04.000Z" itemprop="datePublished">2015-09-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/30/重拾算法计划/">重拾算法计划</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="序">序</h4><p>  自从工作后学习<code>Ruby on Rails</code>后感觉渐渐地自己也变得懒惰起来。<br>因为<code>Rails</code>封装了足够强大的工具，让我很少需要关心怎么去写SQL语句，甚至都已经无法区分SQL语句的几种分类<code>[DDL, DML, DCL, TCL]</code>，<br>几乎<code>migration</code>和<code>active_record</code>可以帮我解决许多事儿，确实提高了很大的生产率，但过度依赖它，只会让我离不开它。<br>这并不是我所希望的，框架毕竟只是提高生产率的工具而已，即使脱离了它也应当具备一定高效解决问题的能力。</p>
<h4 id="不要让你的代码拖累了应用">不要让你的代码拖累了应用</h4><p>  <code>PHP is the world&#39;s BEST language, PHP7 is coming, it brings PHP more powerful</code> - LOL just a jokes。<br>经常看到一些人争论语言的优劣时，会根据一些所谓笼统的概念来判断一个语言的性能快慢和学习成本。这些并非是问题的根本，<br>就好比编译型语言天生就要比解释型语言快很多倍。是的，确实快，但取决于不同平台，不同写法，以及不同场景。为何<code>Erlang</code>中<br>启动一个进程，并不需要太多开销？为何<code>Java</code>里的并没有真实的二维数组的概念？为何<code>jQuery</code>提倡<code>write less do more</code>？<br>为何<code>Ruby</code>程序员需要学习它的语法糖？一个程序的快慢是由代码所决定的，通过学习语法糖和算法，才能最大化的输出代码的价值。</p>
<h4 id="LeetCode">LeetCode</h4><p>  LeetCode是一个Online Judge的平台，它和一些ACM平台不太一样，算法题是它的一部分，它的宗旨更多是，让大家写出优雅<br>的代码，因此它还有<code>Database</code>，<code>Shell</code>等领域。不光能够提升分析问题与解决问题的能力，还能有效的帮助你熟悉<code>SQL</code>，<br><code>ShellScript</code>。</p>
<h4 id="不为刷题而刷题">不为刷题而刷题</h4><p>  玩一些竞技类游戏的时候，我会很在意战绩，因为战绩能带给我一些优越感，但这并不符合我的初衷。<br>  引用一下<code>Perl</code>语言的座右铭：<code>There&#39;s more than one way to do it</code><a href="https://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it" target="_blank" rel="external">TMTOWTDI</a>，不论采用什么语言<br>都应当存在最优解法和最差解法。不能因为一次<code>Acceptance</code>就不再去研究有没有更好的解法？或者更糟的解法？多种解法之间有多么糟糕？<br>他们的benchmark曲线又是怎样的？如果对这些不够了解，是没发真正的理解这道题的考点，自然也就没法享受到它带个你的<code>乐趣</code>。<br>当然<a href="https://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it" target="_blank" rel="external">TMTOWTDI</a>，并不适用于所有情景，<br>在团队协作中或者工作中，尽量的统一代码规范，才是重要的。</p>
<h4 id="怎么执行？">怎么执行？</h4><ol>
<li>和基友采用了Tower.im的看板模式来做多人学习的TodoList</li>
<li>把LeetCode代码push到github<a href="https://github.com/Matrixbirds/LetKa" target="_blank" rel="external">LetKa</a></li>
<li>根据刷题情况定期写<code>日记</code>总结</li>
<li>每周至少一篇刷题分析</li>
</ol>
<h4 id="终">终</h4><p>  学习算法的目的，一方面是为了提高分析、定位并解决问题的能力。另一方面希望自己能够熟悉<code>ruby</code>的语法糖。<br>再就是希望刷题能带给自己更多的idea。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TODO/">TODO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日记/">日记</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-译-JavaScript中的函数式编程-Partial-Function-applications" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/24/译-JavaScript中的函数式编程-Partial-Function-applications/" class="article-date">
  	<time datetime="2015-09-24T15:53:40.000Z" itemprop="datePublished">2015-09-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/24/译-JavaScript中的函数式编程-Partial-Function-applications/">[译] JavaScript中的函数式编程--Partial Function applications</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="序">序</h4><p>最近在研究函数式编程，对函数式编程的概念还是有些模糊，毕竟自己只玩过<code>Impure FPL</code>中得一丢丢FP Feature<br>在使用google的同时，发觉了一些不错的资料，这里选择了我熟悉的JavaScript style – FP文章做翻译<br>翻译的不好欢迎大家评论并且指出:D。Thank ur for reading.</p>
<h4 id="原文链接:">原文链接:</h4><p><a href="https://lostechies.com/derickbailey/2012/07/20/partially-applied-functions-in-javascript/" target="_blank" rel="external">https://lostechies.com/derickbailey/2012/07/20/partially-applied-functions-in-javascript/</a>  </p>
<h4 id="译">译</h4><p>近期，我发现自己用JavaScript做了越来越多的函数式编程，尤其是最近的几天里我正在做一个基于WinJS的项目，并且大量的使用到了Promise，它对我来说是一个挑战。这也让我感到有点奇特，考虑到当时我正对使用<code>Backbone.js</code>构建面向对象的JavaScript应用有热情。但在此同时，JavaScript中有一些非常自然的函数式风格，你可以用函数式风格来做许多非常有趣的东西，我鼓励大家去研究它。</p>
<p>Partial Function Application（部分函数应用）<br>在我研究函数式风格的过程中，我学习到了一个工具 – 部分函数应用，它源自于Wikipedia(维基百科)，允许我们给一个函数提供一个参数，从而产生出一个参数较少的函数。注意部分函数应用不同于柯里化。这两个概念有点类似，但可以确定地是，它们是两个种东西，不能互相颠倒。  </p>
<p>部分函数应用的真正意思是，我们可以把一个预期有2个参数的函数，通过固定第一个参数，先计算第一个参数，然后创建一个部分应用的函数，这样的结果会是返回一个它本身且预期只有一个参数的函数。当再一次调用的时候，将产生与上一次计算的结果。</p>
<p>例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partially apply this function with the "a" parameter set to 1</span></span><br><span class="line"><span class="comment">// 部分应用将这个函数的参数 "a" 设置成了1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> partial = add.bind(<span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// complete the function application by providing the "b" parameter</span></span><br><span class="line"><span class="comment">// with a value of "2". 1 + 2 = 3, so this results in 3.</span></span><br><span class="line"><span class="comment">// 通过给参数b赋值2，完成函数的应用，会和上一次的执行计算。因此则结果是3。</span></span><br><span class="line">partial(<span class="number">2</span>); <span class="comment">//=&gt; 3</span></span><br></pre></td></tr></table></figure></p>
<p>这里，我们使用到了ES5标准中得<code>bind</code>函数来实现 <code>部分应用</code>。<code>bind</code>功能的是：<br>1）绑定一个函数的上下文（<code>this</code> 参数）<br>2）创建一个<code>部分应用函数</code></p>
<p>当调用<code>部分函数</code>时，最终你会得到原本两个参数调用时的结果，<code>部分函数</code>可以被多次使用，并且可以有多个参数。你可以提供一个或多个参数并且可以用<code>bind</code>实现<code>部分应用函数</code>，并且你同样能够对<code>部分应用的函数</code>实现<code>部分应用</code>,当然部分函数的概念也许有点荒谬，但是过了一段时间，它依旧能够完成所有的操作。  </p>
<p>Implementing Partial Application(实现部分函数应用)<br>最基本的方法实现部分函数应用是在支持ECMAScript5标准的浏览器或者解释器上(如NodeJS WinRT)编写代码<br>（注：自从我用WinJS和WinRT在win8系统上工作后，我就坚持一直使用ECMAScript5来编JavaScript写。IE10对这个标准的实现支持的很好，在相当支持ECMAScript5标准的浏览器上写程序十分的有趣。这样你也不用担心跨浏览器兼容性问题，构建WinJS的代码也会十分的整洁）  </p>
<p>尽管你使用的浏览器或者解释器不支持ECMAScript5标准，所以没办法用<code>bind</code>函数轻松实现partial application（<code>部分应用</code>）。<br>自己实现一个这类的函数也不会花费太多的精力，并且有许多种现成的实现方案 - 例如 <a href="http://ejohn.org/blog/partial-functions-in-javascript/" target="_blank" rel="external">this_one_from<em>John</em> Resig</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// John Resig's "curry" function from</span></span><br><span class="line"><span class="comment">// http://ejohn.org/blog/partial-functions-in-javascript/</span></span><br><span class="line"><span class="comment">// which is unfortunately named, as this is not currying -</span></span><br><span class="line"><span class="comment">// it's partial function application.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.curry = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span>, args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args.concat(</span><br><span class="line">        <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// a sample use</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> partial = add.curry(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">partial(<span class="number">2</span>); <span class="comment">//=&gt; 3</span></span><br></pre></td></tr></table></figure></p>
<p>现在你也许不会想去修改JavaScript的原生<code>Function</code>原型链按照以上方式这样扩展（我个人不建议）。但不用担心，<br>你可以用更简单的方式 - 用单独的函数调用来实现同样的效果，例如你可以用Underscore.js这样的提供了partial application<br>类似<code>bind</code>这样的函数，而不是通过污染<code>Function</code> prototype来做到:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using underscore.js "bind" function</span></span><br><span class="line"><span class="keyword">var</span> partial = _.bind(add, <span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">partial(<span class="number">2</span>); <span class="comment">//=&gt; 3</span></span><br></pre></td></tr></table></figure></p>
<p>可能有更多的实现方式，在这里我就大致的列出这两种实现。</p>
<h3 id="案例">案例</h3><p>目前为止我已经知道了一些关于<code>Partial Function Application</code>的一些知识。但是我至今并没有使用它的理由，也不<br>理解它的用处在哪里，在什么情况下用它是明智的。对于我正在用WinJS/WinRt构建基于微软 P&amp;P group(名词可以忽视…)，<br>更像是一种学术研究，然而我还是找到了一些应用场景，编写了一些比不用<code>Partial Function Application</code>更加简洁的代码  </p>
<p>这里有一段来自bennage和我一起用WinJS/WinRT做app的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildThumbnails</span>(<span class="params">files</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> localFolder = applicationData.current.localFolder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Promise to build the thumbnails and return the list of local file paths</span></span><br><span class="line">    <span class="keyword">var</span> whenFolderCreated = localFolder.createFolderAsync(thumbnailFolderName, replaceExisting);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> whenFolderCreated</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">folder</span>)</span>&#123;</span><br><span class="line">          Tiles.copyImages(files, folder);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(Tiles.getFolderNamesFromFiles)</span><br><span class="line">        .then(Tiles.update)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这并不是很糟糕。实际上，它相当的简洁和易读。以上代码使用了大量的<code>Promise</code>和链式调用。<br>每个函数调用后都会返回一个<code>Promise</code>，从而实现链式的调用<code>then</code>函数。这里除了中间那段代码用了<br>内联的函数作为参数是为了通过闭包的方式来得到第二个函数，我想试试有没有办法不需要这样做，来得到<br>一样的效果，我发现<code>Partial Application</code>解决了我的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildThumbnails</span>(<span class="params">files</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> localFolder = applicationData.current.localFolder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Promise to build the thumbnails and return the list of local file paths</span></span><br><span class="line">    <span class="keyword">var</span> whenFolderCreated = localFolder.createFolderAsync(thumbnailFolderName, replaceExisting);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// partially apply the image copier to carry the files parameter with it,</span></span><br><span class="line">    <span class="comment">// allowing it to be used as a promise/callback that only needs to have</span></span><br><span class="line">    <span class="comment">// the `folder` parameter supplied.</span></span><br><span class="line">    <span class="keyword">var</span> copyThumbnailsToFolder = Tiles.copyImages.bind(<span class="literal">null</span>, files);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> whenFolderCreated</span><br><span class="line">        .then(copyThumbnailsToFolder)</span><br><span class="line">        .then(Tiles.getFolderNamesFromFiles)</span><br><span class="line">        .then(Tiles.update)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个版本的代码里，内联函数一个用<code>bind</code>方法实现了<code>部分应用的函数</code>局部变量代替了，<br>我通过应用了第一个参数，这样会返回一个只需要一个参数的函数。因此这个参数是由<code>then</code>方法中得Promise链返回的所需值，<br>我可以提供这些<code>部分应用的函数</code>调用，一切按预期执行。</p>
<h4 id="不，真是这样吗。还是仅有这一种案例？">不，真是这样吗。还是仅有这一种案例？</h4><p>当然这是一个极其简单的例子，很可能认为是不必要的。原先的代码并不是相当的糟糕，可读性可能对一些人来说不是很差，<br>但是在结尾使用<code>then</code>链式语句会十分优雅，它有着截然不同的函数式风格和流，这让我感到十分的易读，我像是在<br>看一序列代码的图解，这让我爱不释手。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-译-Templating-with-ERB-HAML" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/15/译-Templating-with-ERB-HAML/" class="article-date">
  	<time datetime="2015-09-15T06:37:33.000Z" itemprop="datePublished">2015-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/15/译-Templating-with-ERB-HAML/">[译] - 使用ERB&amp;HAML更好的使用模板引擎</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://tutorials.jumpstartlab.com/topics/better_views/erb_and_haml.html" target="_blank" rel="external">Better Views Templating with ERB &amp; HAML</a></p>
<p>  Rails默认的模板引擎语言叫<code>Embedded Ruby</code>(简称<code>ERB</code>)。模板文件存放在<code>/app/views/</code>目录下并且它们的名字与controller和action相互对应。<br>每当你需要用<code>ERB</code>的时候Rails已经帮你默认配置好了。</p>
<h2 id="回顾一下ERB">回顾一下ERB</h2><p>  在ERB中 我们有3个主要的标记型元素:<br>    · HTML和文本没有使用这些元素，直接展示在页面上<br>    · 使用<code>&lt;%=</code> 和 <code>%&gt;</code> 包含Ruby的代码，并且会在标记元素中输出<br>    ·</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-gulp-自动化构建Web前端" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/12/gulp-自动化构建Web前端/" class="article-date">
  	<time datetime="2015-09-12T12:09:33.000Z" itemprop="datePublished">2015-09-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/12/gulp-自动化构建Web前端/">{ gulp: 自动化构建Web前端 }</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="序">序</h4><p>最近工作中因新增业务，需要做一些脱离业务数据的页面demo出来，为了降低一些没意义的重复工作量，<br>我发现了<code>gulp</code>这个前端自动化任务构建工具。并被它的<code>streaming</code>所吸引。打算写篇博客来总结一下。</p>
<h3 id="什么是Gulp，它能用来做什么？">什么是Gulp，它能用来做什么？</h3><p><code>Gulp</code>是一个基于<code>Node.js</code>流式构建前端的自动化任务（Task）工具，什么是自动化任务？可以理解为C中的<code>Makefile</code>，<br>编译资源并且发布成应用。前端？有哪些资源需要被编译？并且要如何发布？</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gulp/">gulp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stream-build/">stream build</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web-fontend/">web fontend</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自动化/">自动化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Redis-Cookbook-Chapter-1-An-Introduction-to-Redis" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/07/Redis-Cookbook-Chapter-1-An-Introduction-to-Redis/" class="article-date">
  	<time datetime="2015-09-06T16:11:04.000Z" itemprop="datePublished">2015-09-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/07/Redis-Cookbook-Chapter-1-An-Introduction-to-Redis/">Redis Cookbook - Chapter 1. An Introduction to Redis</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="何时使用Redis?">何时使用Redis?</h3><h3 id="情景:">情景:</h3><p>  几乎每个应用都需要存储数据，并且经常会数据变动很快。 至今，仍然有许多应用采用RDBMS(关系型数据库管理系统) 如：Oracle, MySQL, or PostgreSQL。然而随着一种新存储模式得出现，从而可以把无模式的数据存入更有效的NoSQL中，选择是否使用SQL数据库或者NoSQL经常是设计一个成功应用中的第一步。</p>
<h3 id="解决方案:">解决方案:</h3><p>  考虑是否选用SQL还是NoSQL来存储数据的关键2个点是：性质和使用模式。一些数据适合用关系型存储引擎，一些数据则适合独立于性质的NoSQL引擎，像<code>Redis</code>，或者别的代替品。  如果你不需要依赖于特有的RDBMS的特性并且需要高性能和健壮性的非关系型数据库，那么NoSQL可能是最理想的选择。因此决定是否用RDBMS还是NoSQL存储引擎，你需要看看一些特定的东西，它们可以帮助你做决定。另外要记住，通常两者一起使用是必要的。<br>  当工作在Web上时，你的数据和数据模型经常随着功能和业务的更新变化。改进数据库设计在关系型数据库中支撑起这些改变是相当痛苦的过程，特别是你不能承担起宕机的时候，人们通常无法忍受宕机，因为应用被期望每周24小时都在运行。在最近的一次Mongodb的演讲中，<code>Jeremy Zawodny</code>在他的<a href="http://blog.zawodny.com/category/craigslist/" target="_blank" rel="external">craigslist</a>中提到他们是如何用了两个月的时间改造了他们的档案服务的数据库设计<br>  是一些特别适合非关系型存储的数据案例，事务细节，历史数据，服务日志。它们通常是高度动态的，经常改动并且他们的存储往往增长迅速，需要不断的调整<code>schema</code>来存储他们，通常他们也不会感到<code>关系型</code>，其中的数据也不倾向于和其他类型数据建立关系，这是一个好的迹象表明他们可以用比RDBMS好的其他类型数据库。<br>  另一种用于衡量是否用NoSQL的办法就是你自己是否找到不寻常的数据由于性能原因，不再从关系型系统中收益，例如一致性和冗余性检查。<br>  需要记住的事，使用NoSQL数据库的时，通常不会提供ACID(原子性，一致性，分离线，持久性)，或者仅仅提供一部分。这需要他们做一些决策否则不可能。<br>  <code>Redis</code>提供了部分ACID的支持，它是设计基于单线程实现的(保证 一致性 分离性)，并且如果配置总是<code>appendfsync</code>会完整的支持，提供持久化。<br>  性能也会成为一个关键因素。NoSQL数据库通常比较快，特有的如写入操作，让他们成为应用的优势是写入重。<br>  以上说明，尽管NoSQL看起来更灵感，也还有强大的参数为存储关系型数据在RDBMS，如果你有可预测的数据，是一个正常的结构，你可以获得使用关系型数据库的好处。在做之前一定要先关注数据再去做决定。</p>
<h3 id="不要相信炒作">不要相信炒作</h3><p>  NoSQL数据库，例如 Redis 上手快，简单，适用于许多现代问题。但是相比下之下，选择一件正确的工具工作总是很重要的。发挥你工具的优势可以通过观察你的存储,多久你会访问它,以及数据(及其模式)如何随时间变化。<br>  一旦你衡量过所有的选项，选择SQL(稳定的、可预测的关系数据)还是NoSQL(临时、高度动态数据)应该是一个简单的任务。提前做这种想法会节省很多麻烦在未来数据迁移工作。<br>  在NoSQL数据库之间也有许多大不同地方，如你需要账号。MongoDB是一个功能重的文档型数据库，允许你执行区间查询，正则表达式搜索，索引，MapReduce。你需要衡量所有的因素，当你选择作为你的数据库时。就和之前说的一样，问题归结为你的数据是什么和你锁需要的模式是什么。<br>  例如，Redis是一个极快的，完美的适合构建写操作频繁的应用，数据长发生变化，数据适合Redis的数据结构(例如，分析数据)。一个场景，你可能不能使用Redis如果你有一个非常大的数据集，只有一小部分是“热数据”(经常被访问)或数据集情况下你不适合在内存中。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-使用hexo搭建个人博客" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/06/使用hexo搭建个人博客/" class="article-date">
  	<time datetime="2015-09-06T02:41:31.000Z" itemprop="datePublished">2015-09-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/06/使用hexo搭建个人博客/">使用hexo搭建个人博客</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="简介">简介</h3><p>  hexo 是一个基于nodejs实现的静态博客框架,具有本地构建项目,以及发布到git得功能</p>
<h3 id="搭建步骤">搭建步骤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 安装git环境  </span><br><span class="line">- npm install -g hexo  </span><br><span class="line">- <span class="built_in">cd</span> /deploy_directory &amp;&amp; hexo init <span class="comment">## 生成hexo的项目文件</span></span><br><span class="line">- npm install <span class="comment">## 安装hexo的项目依赖</span></span><br></pre></td></tr></table></figure>
<h3 id="hexo_基本命令">hexo 基本命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- hexo new <span class="string">"文章名"</span> <span class="comment">## 新建文章  </span></span><br><span class="line">- hexo generate <span class="comment">## 生成hexo资源文件  </span></span><br><span class="line">- hexo deploy   <span class="comment">## 发布hexo  </span></span><br><span class="line">- hexo server   <span class="comment">## 启动hexo本地服务</span></span><br></pre></td></tr></table></figure>
<h3 id="hexo的发布和部署">hexo的发布和部署</h3><ul>
<li>hexo分为两种目录结构<ul>
<li>发布结构: <code>带有发布目录以及_config.yml 部署配置文件</code></li>
<li>部署结构: <code>只带有静态文件 并没有部署文件 (该结构只有在执行hexo deploy时会生成)</code></li>
</ul>
</li>
</ul>
<p>因此本文采用了两种分支来分别存放这两种不同的结构</p>
<p>  master: 分支存放部署结构<br>  deployer: 分支存放发布结构</p>
<h3 id="部署到github,_gitcafe">部署到github, gitcafe</h3><ol>
<li><p>修改当前项目根目录的package.json中的部署文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"你项目的名称(随意填)"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.0.0(版本同上)"</span>,</span><br><span class="line">  <span class="string">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"hexo"</span>: &#123;</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"3.1.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"hexo"</span>: <span class="string">"^3.1.0"</span>,</span><br><span class="line">    <span class="string">"hexo-generator-archive"</span>: <span class="string">"^0.1.2"</span>,</span><br><span class="line">    <span class="string">"hexo-generator-category"</span>: <span class="string">"^0.1.2"</span>,</span><br><span class="line">    <span class="string">"hexo-generator-index"</span>: <span class="string">"^0.1.2"</span>,</span><br><span class="line">    <span class="string">"hexo-generator-tag"</span>: <span class="string">"^0.1.1"</span>,</span><br><span class="line">    <span class="string">"hexo-renderer-ejs"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="string">"hexo-renderer-stylus"</span>: <span class="string">"^0.3.0"</span>,</span><br><span class="line">    <span class="string">"hexo-renderer-marked"</span>: <span class="string">"^0.2.4"</span>,</span><br><span class="line">    <span class="string">"hexo-server"</span>: <span class="string">"^0.1.2"</span>,</span><br><span class="line">    <span class="string">"hexo-deployer-git"</span>: <span class="string">"0.0.4"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先需要分别在github, gitcafe上建立一个repository</p>
<p>github上repository的名字为[username].github.io<br>gitcafe上repository的名字为[username]</p>
<p>github上需要部署到<code>master</code>分支, gitcafe上则需要部署到<code>gitcafe-pages</code>分支  </p>
</li>
<li><p>修改根目录下面的: <code>_config.yml</code><br>把<code>deploy</code>部分替换成如下  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deploy:  &#10;  type: git&#10;  repo:&#10;    github: git@github.com:Matrixbirds/matrixbirds.github.io.git,master&#10;    gitcafe: git@gitcafe.com:Matrixbirds/matrixbirds.git,gitcafe-pages&#10;  message: &#34;deploy both of on github &#38;&#38; gitcafe&#34;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行<code>hexo generate &amp;&amp; hexo deploy</code>生成静态文件并且发布到目标项目地址的目标分支</p>
</li>
<li><p>访问url进行测试 <a href="http://matrixbirds.github.io">http://matrixbirds.github.io</a>, <a href="http://matrixbirds.gitcafe.io" target="_blank" rel="external">http://matrixbirds.gitcafe.io</a></p>
</li>
<li><p>如果上述测试没问题则可以push发布版本到<code>deployer</code>分支</p>
</li>
<li><p>如果在<code>hexo deploy</code>之前当前目录存在<code>.deploy_git目录</code>则应当先删除该目录后再执行发布命令</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 Matrixbirds
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    

<script>
	var yiliaConfig = {
		fancybox: undefined,
		mathjax: undefined,
		animate: undefined,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: undefined
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






  </div>
</body>
</html>