title: 译-what-is-reactive-programming
date: 2016-10-17 12:17:16
tags:
 - 翻译
 - reactive programming
---

翻译[what-is-reactive-programming](https://medium.com/reactive-programming/what-is-reactive-programming-bc9fa7f4a7fc#.1emifplpz)

#### 什么是响应式编程？  
  要理解响应式编程，理解它的编程范式以及它背后的机制，可以帮助我们了解当今的开发者以及公司所面临的挑战，与十年前的挑战的差距。  
  这些年对于开发者和公司来说有两个很明显的变化：  
  * 硬件
  * 互联网  
  虽然"围着篝火讨论过去"被认为是最lowbee的一种对话形式，但我们应该通过探索我们职业的历史，来解决每个开发者即将面临的问题。  

#### 有什么东西都不同于现在了？  
  有大量的知识，被我们在处理几十年前的计算机领域知识中发掘。响应式编程是一种尝试推广的知识，为了讲它应用在下一代软件中。

#### 1999年
  我开始学习java的时候是1999年，当时在Canadian Imperial Bank of Commerce实习：  
  * 那时候互联网有2亿8千万的用户。  
  * J2EE那时候只是Sun MicroSystems心中的梦想。  
  * 网银应用属于刚起步阶段 - 5岁所有  
  早在1999年以前我就开始遇到了并发的问题。那时候的解决方案涉及到线程和锁，让复杂的东西变得正常仅针对于开发者中的老司机。  
  当时Java的主要卖点在于"write one, run anywhere"(一次编写到处运行), 但是`anywhere`是指安装了JVM的操作系统里，  
  那时候还没有云的概念，以及大量的并发连接，我们现在正在设计的东西在互联网时代。  

#### 2005年
  2005年过去的时间并不长，但是计算机和互联网却有了不小的改变，正是J2EE,SOA(面向服务架构)和XML热潮，Ruby on Rails的诞生  
  对于痛苦的J2EE容器部署模型是巨大的冲击。
  一些有趣的事实：
  * 互联网以及有了十亿的用户。
  * Facebook 以及有了5.5亿的用户。
  * YouTube 在2005年的二月诞生了。
  * Twitter 还没出生，(诞生于2006年)
  * Netflix 还没有介绍视频流(诞生于2007年)  

#### 2014年
  在2014年，也正是写这篇博客的时间，按照[Internet Live Stats](http://www.internetlivestats.com/internet-users/)的统计大约有将近29亿5千万互联网用户。  
  中国就有6亿4千万的互联网用户。美国有2亿8千万。  
  如今两个最流行的网站：
  * Facebook 有13亿用户。
  * Twitter 有2亿7千万用户。  
  时代在变化。一个单一的网站如今可以尽可能的处理更多地流量，然而互联网变化还不到10年。  
  ![https://cdn-images-2.medium.com/max/1200/1*HAoewX140mJ8JnogRGPr5g.png](https://cdn-images-2.medium.com/max/1200/1*HAoewX140mJ8JnogRGPr5g.png)  
  很容易看出，我们正在面临技术栈趋势的问题，期望，以及软件在我们生活中的重要性。还可以看出，一些范式没有继续上升到现在，当然未来也不会。  

#### 响应式的四大原则  
  响应式应用基于四大指导原则。  
  * 响应式程序是目标  
  * 响应式程序具备可伸缩以及弹性。响应没有可伸缩性以及弹性是没法实现响应性的。  
  * 消息驱动架构是可伸缩性、弹性以及最终响应系统的基础。  
  让我们探索以高层次来探索每一个原则，以便于理解为什么它们必须一起应用，以提高现代环境软件开发的质量。  

#### 响应式
  当我们说一个应用程序是响应式的时候，我们想表达什么？  
  响应式系统是迅速对所有用户做出反应，为了确保固定且正确地用户体验。  
  在不同的场景下，快速以及正确地用户体验依赖于响应式应用的两个特性：弹性以及可伸缩性。  
  消息驱动架构是响应式系统的根基。  
  为什么响应式系统架构如此重要？  
  在异步的世界里，有以下这样一个场景：你正在烘焙一壶咖啡，但是你突然发现缺少奶油和糖。  
  *   一种解决方案：  
    * 开始烘焙一壶咖啡  
    * 当咖啡在烘焙的时候，走到商店  
    * 买奶油和糖  
    * 回到家  
    * 咖啡刚好烘焙好，开始喝咖啡  
    * 生活如此美好  
  
  *   另一种解决方案:  
    * 去商店  
    * 买奶油和糖  
    * 回到家  
    * 开始烘焙咖啡  
    * 耐心的看着咖啡在烘焙  
    * 对咖啡因开始反感  
    * 烘焙真TM麻烦  
  
  如你所见，在消息驱动的架构下异步边界提供了时间和空间的解耦。让我们继续探索异步边界的理念。  

#### 一致性在沃尔玛加拿大的应用  
  在加入类型安全之前，我正带领着一个用Scala语言和Play框架的团队开发[沃尔玛加拿大的电子商务平台](http://walmart.ca/)。  
  我们的目标是一致性的用户体验，无论在一下的任何场景：
  * 在桌面，平板以及移动设备的浏览器打开[welmart.ca](http://walmart.ca/)  
  * 在流量达到高峰时，不论是在秒杀级别还是在持续保持  
  * 一个重大的基础设施故障，例如数据中心  

  在以上的场景下，无论是响应时间和还是用户体验必须保持一致。一致性的重要性是你网站交付的根本，考虑到如今网站能代表你的牌面。  
  一个糟糕的体验比起一个破落不堪的店铺更难以被忘记或忽略，因为它们都发生在网上。  

#### Gilt的零售的响应式  
  在电子商务领域一致性不允许出现一次意外，在[Gilt](http://gilt.com/)中有这样一个场景，每天中午都会放上即使抢购会经历秒杀级的流量。  
  让我们设想一下即使抢购的网站应该有的用户体验，如果你的浏览器在上午11:58和下午的12:01访问时，你应当得到同样地用户体验，但这时Gilt网站的访量正处于高峰期。  
  Gilt实现一致的用户体验以及响应体验，通过实现Reactive(响应式)实现。想要更多地了解Gilt从Rails迁移到基于Scala的微服务架构，可以了解一下[采访Gilt的vp Eric Bowman的文章](http://readwrite.com/2014/05/08/gilt-eric-bowman-interview-scala-rails-jvm-reactive-platform)  

#### 弹性  
  大多数的应用程序被乐观的设计和开发着，没有一些特殊场景的考量。这看上去会有较少的几天会出现程序gg的情况或者被黑客攻击到宕机，数据丢失，有损名誉。  
  弹性系统应当有良好的设计以及合理的架构原则，为了保证在极端的场景下也能有和普通场景一样的体验。  
  虽然Java和JVM可以无缝的将单独一个应用程序部署到不同的操作系统。如今(201x)年的互联应用，都是程序级别的组合，要保证相互的可连接性，以及安全性。  
  现在的应用程序会有许多个子程序构成，整合成一个web服务或者是别的什么网络协议。如今要构建一个程序，可能会依赖好多个外部的服务。它可能会服务给大部分的客户端，有用户也有别的系统。  
  还有多少开发者，把用心去整合这些复杂的东西：  
  * 有没有分析并建模是否需要有外部的依赖?  
  * 有没有Document应在整合的每一个服务的理想时间内响应。并且做在高峰值流量以及持久访问的性能测试，合理的评估是否符合预期。  
  * 有没有将所有的性能，失败的场景和其他的非功能性的期望都作为核心应用程序的逻辑的一部分。  
  * 有没有分析并且测试每个服务可能失败的场景  
  * 有没有分析外部依赖的安全性，考虑整合是否会造成漏洞？  
  弹性在大部分应用中是最薄弱的环节，尤其是业务复杂的，但是弹性作为一种以后才考虑的传说很快就要GG。现代应用程序必须是有弹性的才能保证在真实地世界里和不理想的环境里保证能够即使的响应。  
  性能，安全性和稳定性都面临着弹性问题。你的应用必须做到所有方面的弹性，而不只是一部分。  

#### 消息驱动中的弹性  
  构件合理的消息驱动好处，你会轻松的许多有价值的基础构件块。  
  `隔离`被作为系统中的自我修复方案存在。适当的隔离，让我们可以把每个类型的工作和组件分离，以便于了解它失败的风险，性能的特点，占用的CPU以及内存等等。  
  一个单独的构件的出错不会对整个系统产生影响，同时我们可以针对这个组件来完成修复。  
  位置透明性(原文[Location transparency](https://en.wikipedia.org/wiki/Location_transparency))让我们有能力在不同的进程中的不同的集群节点里交互，就像在同一台机器的进程里。  
  `划分单独的错误频道`允许我们把错误信号重定向到某个地方，要比直接throw到调用栈会更好一些  
  这些因素帮助我们实现可靠的错误处理以及容错能力纳入到我们的应用。这些因素表现的实际实现像是[Akka的supervisor层次结构]。  
  核心构件块提供了一套消息驱动的架构，这不仅有利于弹性，同时还具有响应性，不论是良好的场景下还是极端的场景下。  

#### 没有弹性造成一个价值4亿4千万美元的伤  
  回顾一下[2012年Knight Capital Group软件故障方面的积累](http://money.cnn.com/2012/08/06/investing/knight-capital-agreement/index.htm)。  
  在软件的升级过程中，另一个休眠的整合程序在不经意间被激活了，开始放大了交易量。  
  接下来的45分钟发生的事是一场噩梦。  
  Knight自动的交易系统被纳斯达克的错误交易所淹没，把公司的数十亿美元投入到了不合理的地方。它让Knight公司花了4亿4千万美元才扭转回来。  
  在Knight公司的小故障期间，Knight公司的交易淹没了纳斯达克，最终被纳斯达克叫停。  
  在当天Knight的股票就下跌了63%，他们勉强的生存了下来。只有投入股市的股票被卖出去的才收回一些价值。  
  Knight系统虽然性能很高，但是它并不具备弹性。光有性能没有弹性，这导致了Knight公司碰到了这种问题，缺没有安全的终止方案。避免bug造成这样的严重的损失。  
  这样导致他们在45分钟就损失了大量的资金。  
  这就是因为开发的过程都只有站在理想的角度考虑。如今软件已经成为我们生活和公司核心的一部分，如果没有良好的设计，在不理想的环境下，即使是一小时，损失也会非常的严重。  

#### 伸缩性  
  弹性和伸缩性可以协力帮你创建具有一致性的响应式应用。  
  一个具有伸缩性的系统，可以在多负载的情况下轻松的升级，并且保证服务的响应性。  
  在网上买东西的骚年都清楚一个事实：当你的东西热销的时候，流量会很大。通常情况下，除了刻意的网络攻击。  
  正常情况大量流量的操作是被允许的。当出现有大量的流量需要给你支付金额。  
  因此你要如何处理突如其来的任持续增长的请求？  
  首先选择好方案，第二选择好语言工具来实现你的方案。  
  `然而大多数的程序员认为应该怎么做是按照语言和框架所推崇的。大多数人因为工具的约定，让他们难以去有更多的思维，来决定如何处理更多的情况。因为一些工具致使他们无法站在自己的环境下做出决定。`  
  如果你在技术层面有独立的分析能力以及设计原则，那么你已经远远领先了他们。  

#### 基于线程并发的限制  
  选择一种并发模型的框架是很重要的一个技术决策。有两种类型的高级并发模型：
  * 传统的基于调用栈和内存共享的线程并发模型。
  * 消息驱动模型  
  一些流行的MVC框架例如Rails就是基于线程的并发模型。这种类型的框架特点包括：
  * 共享可变状态  
  * 一个线程处理一个请求  
  * 并发的访问可变的变量和对象实例时通过管理锁和其他的复杂同步机制。  
  结合以上的特性以及动态类型，像ruby这样的解释性语言，你会很快的达到性能以及伸缩性的瓶颈。  
  对于任何一种语言根本上也是一样的，毕竟它的核心实现是一个脚本语言。  

#### 伸缩？是横向还是纵向？  
  让我们考虑一下几种伸缩的方式。  
  `纵向伸缩`涉及单独一个CPU或者服务器，通常会需要资金的支持，升级硬件。  
  `横向伸缩`涉及分布式计算跨越集群，可以在不增加设备成本的情况下（比如说可以用云平台），由于你的系统是基于时间和空间的概念，很难实现。  
  正如之前我们说说，异步边界解耦了空间和时间，让我们的更好的实现横向伸缩，这样也称之为弹性。  
  横向伸缩的优势是可以更充分的利用好服务器资源，而且弹性可以根据你的需求来增加，`纵向伸缩`的能力是响应式应用的最终目的。  
  响应式应用很难基于多线程的框架构造，因为横向扩展一个基于共享可变状态、多线程和锁是非常困难的。开发者需要考虑在单机的情况下利用好多核的机器，还需要在集群里充分利用。是 
  共享可变状态会增大横向伸缩的实现难度。学过多线程的人大家都清楚共享变量在多个不同的线程里会出现线程安全的问题。  

#### 消息驱动  
  消息驱动架构是响应式程序的基础。消息驱动可以用事件驱动，基于actor，或者混合二者实现。  

  一个事件驱动系统通过监控一个或者多个观察者实现。它不同于命令式的程序设计，它不会因为调用会阻塞程序而等待直到它响应调用的结果。  
  事件不会指向同一个对象，而是根据监听它的变化，这有一定的影响，接下来让我们。  

  基于Actor的并发模型是基于消息传递架构的衍生，消息会指向一个接收者 - 一个actor。  
  消息也许会穿越线程边界，也可能在不同的物理机上之间传递到另一个actor的信箱。Actor的弹性特性可以按照需求`横向伸缩`  
  actors可以在分布跨越在网络里，如果他们可以通过相互通信，共享同样的内存。  

  消息以及事件的主要区别在于消息可以指向性的，事件是触发性的。消息有一个明确的目标，然而事件可能有多个观察者。  
  接下来让我们探索一下事件驱动以及基于actor的并发模型的细节。  

#### 事件并发模型  
  传统的应用程序采用命令式的风格开发 - 一系列有步骤的操作 基于当前的`调用栈`。`调用栈`的主要目的是保持跟踪子程序(routine)的调用者，然后执行子程序(routine)，会阻塞当前的主线程，等待子程序的执行，最终会随着子程序的返回值把控制权返回当前调用者的线程。  
  从表面上来看，事件驱动的应用程序并不关注`调用栈`，它只是触发事件。事件也许会被编码成消息放置在用来监听多个观察者的队列里。事件驱动和命令方式的两者的区别在于一个调用者是非阻塞的，一个则是需要阻塞线程等待响应结果。  
  事件循环虽然可能是单线程的，但是并发仍然是可行的。可以通过调用子程序实现相关业务，当收到一个请求的时候会有事件循环的线程处理（有时候事件线程是一个单独的线程），而不是收到请求之后阻塞线程指导处理完之后才返回结果。  
  
  基于事件驱动架构的可能会引起[callback hell](http://callbackhell.com)影响代码的可维护性。发生callback hell的原因是，消息的接收方是基于异步回调传递的，而不是直接的通过引用找到的。  
  callback hell又被称作the Pyramid of Doom，它的解决方案在于代码的编写，然而这样可能会造成难于调试。  

#### 基于Actor的并发模型  
  Actor的并发模型是通过异步的传递消息在多个actors之间实现。  

  一个Actor具有如下的几种属性：
  * 一个接受消息的信箱  
  * actor的逻辑是会根据pattern matching的方式决定处理收到哪种类型的消息。  
  * 状态隔离而不是共享状态，状态只会存在自己的上下文中。  

  Actor有点类似事件驱动模型，它支持通过调用栈传递轻量级的消息。Actors之间可以来回传递消息，甚至可以给它们自己传递消息。actor可以给自己传递消息，如果消息处理时间很长，它会等待处理结束后从`信箱`里提取消息，继续处理。 
  基于Actor的模型比事件驱动更多的地方有，能够实现跨网络节点可扩展性的计算，每条消息指向每个Actor，可避免callback hell。这些特性可以让你更好的设计、构建和维护伸缩性更高的程序，而不是纠结于时间和空间，深层的回调嵌套。  
  你只需要关注Actor之间的消息传递。  
  Actor架构下的另一个好处是组件的松耦合化，这让调用者不在因为响应结果阻塞线程，因此调用者会很快的继续回到他们的岗位工作上。被调用的子程序(routine)会封入一个Actor，只有必要的时候才会调用子程序(routine)。  
这样创造了更多的可行性，例如跨集群的分布式的子程序，因为调用栈没有和应用程序的内存空间耦合，Actor让部署抽象的配置化，而不是程序化。  
  Akka是一个基于Actor的工具和runtime，它是类型安全的应式平台的一部分(原文:  part of the [Typesafe Reactive Platform](https://www.lightbend.com/platform))，它是为了构建JVM上的高并发，分布式，可容错的，且基于Actor的响应式程序。  
  Akka有一些难以执行的功能来用于构建响应式应用，例如`supervisor hierarchies`提供了可伸缩性的分布式`worker`和弹性。如果想深入挖掘Akka的，已经超出本文的范围，我强烈推荐去看[Let it Crash blog](http://letitcrash.com/)之类的更多Akka的内容。  
  也同样推荐[ Benjamin Erb’s ]()的毕业论文，[Concurrent Programming for Scalable Web Architectures](http://berb.github.io/diploma-thesis/original)。  

#### 总结（译者本人的一些观念）  
  <What is reactive programming>作者并不是想告诉大家，`Reactive Programming`是一种当今时代在开发者圈子里一种流行的趋势，不管你使用什么语言什么工具，只要你的用户量是持续增长的，服务需要是高可用的。
你就应该在设计、开发的角度时，考虑未来要如何提高可扩展性，如何做容错方案，如何做到弹性。这是每一个开发者应该学习的而不是把`Reactive Programming`当做一种新的趋势或者说当做新技术。
这种东西其实很早以前就已经出现了。因为当时我们身边的机器没有现在发展的迅速，猜测是因为这个原因没有得到广大的推广，选择一种编程Pattern或者选择某种架构的时候，我们应当从当前的资源（例如基础设施，硬件），考虑以便于充分利用资源，做绿色设计。  
而不是由于你的某种框架的Pattern死板，促使你写的代码也很死板，无法满足需求。所以基础还是很重要的，程序员应该多注重基础修行，而不是为了追求某个框架的Best Practise而编写代码。