title: 【译】PLop-95 -- half-sync-half-async
date: 2017-08-22 01:43:45
tags:
  - concurrency
  - pattern
  - server
---

## 翻译的动机    
  任职服务端开发也有2年之久，个人是个野路子程序员，使用的都是Lowbee脚本语言。并没有过真·计算机领域知识学习。
++严重欠缺计算机科学背景，但是由于本人工作和生活中长期使用Linux，并且希望向女装程序员水平上靠拢，加上对于并发一直是懵懵懂。为了日♂后可以欢乐的play。因此尝试通过翻译这篇paper来作为一个知识点的学习。毕竟计算机是实战科学，因为工作目前不会接触高访问量的需求，所以后续有时间我会补上代码加以巩固知识点。
  本文中部分章节可能会有缺漏，本人英译有限，有什么错误或者缺漏可以私我yooobuntu@163.com（反正也不会有人看。。）

# 正题  

## 动机  
  如图[1]所示，一个基于BSD UNIX的软件架构的网络子系统。BSD UNIX 内核会调度异步通信设备（如：网络适配器和终端）和正跑在系统的程序，当网络数据包到达通信设备后，会由硬件发起一个电信号（也就是我们俗称的interrupt[中断])异步的发送给中断处理程序（也就是说发送这个电信号的操作，并不会立即执行并返回响应给发信号的硬件大爷），然后数据包会被中断控制器发送给操作系统内核（我们可以把操作系统前后端分离，前端视为用户态，后端视为内核，用户态只具有用户权限和申请获取资源能力，内核具备最高权限和资源分配能力）。这些中断处理程序会接受来自设备的数据包，并且会处理成高层协议（如：IP，TCP，UDP）。合法的数据包包含的应用程序数据会存在Socket层的队列中。内核酱会分发给等待消费数据的用户进程。这些受到数据包的骚年，会调用`read`内核api，用同步的方式读数据包里的内容。用户进程任何时候都可以调用`read`，当数据抵达时，当前进程会睡眠，直到数据成功抵达时。  
在BSD架构中，内核异步地执行I/O响应给设备中断。相反的是，在用户态程序中同步地执行I/O。这种分离的关注点被称为"半同步、半异步"并发IO结构用于处理下面的两个问题：  
  1.简化编程：  
  使用异步I/O模型编程会比较复杂，因为输入和输出操作是中断触发的。异步会引发导致时钟问题和竞争问题，当前的线程可能控制权可能会被中断程序抢占，此外，中断驱动的程序运行栈会依赖额外的数据结构。这些数据结构用于显示地保存和恢复状态，这些状态是由事件异步地产生。再就是，调试异步程序比较困难，由于在程序运行时，在代码不同地点，产生了来自外部的事件。  
相反，基于同步IO编写的程序相对于简单，因为I/O操作会在定义处产生，代码会按序处理。此外，程序会被同步I/O阻塞，等待I/O操作完成。使用阻塞I/O允许程序维护状态信息、调用历史，在运行时的栈活动记录里，而不是需要额外的数据结构管理。因此强烈建议使用同步I/O模型简化编程模型。  
  2.高效率地运行：  
  异步I/O模型有效地映射到硬件设备上，通过发送中断驱动。异步I/O可以同时处理通信和计算。另外，上下文切换开销小，因为维护程序所需的信息的状态数量相对比较小。因此，这里也是强烈建议使用异步I/O模型提高运行性能。  
  相反。完全地使用同步I/O可能是低效的，当每一个事件源（如：网络适配器，终端，计时器）相关的单独的活动对象（如：进程，线程），每一个这些对象都包含了一些资源（如：栈，一组寄存器）会发生阻塞，这时候就需要等待产生阻塞的事件源响应完成。因此，同步I/O模型会减少时间，用于创建必要的空间，调度，分发，结束一个活动对象。  

## 解决方案  
  为了解决简化编程模型和提高运行效率之间产生的担忧，我们使用`Half Sync/Half Async`模式。这个模式以有效且良好的方式集成同步I/O和异步I/O模型。在`Half Sync/Half Async`模式中，
高级任务（如：数据库查询和文件传输）使用同步I/O模型，可以达到简化编程模型。相反，低级任务（如：处理网络控制器的中断）使用异步I/O模型，从而强化执行效率。因为在系统中的高级任务比低级任务更多，这个模式将异步处理的复杂性放置软件架构中的单独一层内。同步通信任务和异步通信任务会被编号并且有序的放入队列层。  

## 适用性  
  使用`Half Sync/Half Async`模式  
  * 系统处理过程有这些特点：  
    - 这个系统必须执行任务响应异步产生的外部事件。  
    - 对于事件源使用独立的线程处理同步I/O是低效率的。  
    - 系统中的高级任务在同步I/O模型下，编程模型非常的简单。  

  * 一个或多个任务必须在单个线程控制下执行，而其他任务可能会从多线程里得到收益。  
    - 例如，历史库X-windows、SUN RPC 通常不可重复执行。因此多线程控制不能在并发情况下安全的调用这些库函数。但是，为了确保服务质量以及享受多CPU的好处，把大量数据传输和数据库查询操作放入独立的线程中执行可能是必要的。`Half Sync/Half Async`模式会抽离多线程程序中的单个线程，这个解耦可以满足不可重复执行函数的需求，不需要写额外的维护代码，以至于它们可以正确的执行。  

## 结构和参与者  
  如图[2]所示是`Half Sync/Half Async`模式的设计参与者设计结构。参与者分为以下几种  
  * 同步任务层（用户态线程）  
    - 这层执行高级I/O会是用同步的方式传输数据，这些任务会放入队列层的消息队列中。不像异步层，同步层的任务是活动对象，有自己的允许栈和寄存器。因此当执行同步I/O时他们会阻塞。  
  * 队列层（Socket层）  
    - 这层为同步任务层和异步任务层，提供了同步和缓冲区。I/O事件被缓冲在队列层的消息队列中的异步任务处理，以便后续用同步任务检索。  
  * 异步任务层（BSD UNIX内核）  
    - 这层为处理来自外部事件源（如：网络接口、终端）的低级任务。不像同步层，异步层的任务是被动对象，所以他们没有自己的运行栈和寄存器。因此他们不会无止境地阻塞在任何单个事件源上。  
  * 外部事件源（网络接口）  
    - 外部设备（如：网络接口、磁盘控制器）生成事件的会被异步任务层接收并处理。  

## 合作  
 如图[3]所示，`Half Sync/Half Async`模式下的参与者之间的活动合作过程：当有输入事件抵达外部事件源（输出事件也是一样的方式处理）。这些合作过程被分成三个阶段：  
   * 异步阶段 - 该阶段，外部事件源会与异步任务层通过发送中断和异步事件通知通信。  
   * 队列阶段 - 该阶段，队列层提供明确的同步点，这样缓冲区消息会把在同步和异步任务层之间传递以响应给输入事件。  
   * 同步阶段 - 该阶段的任务在同步层会检索放在队列层中的异步任务。注意协议决定数据以什么方式被传递，队列层负责调解相交的同步和异步任务层相交的通信。  
异步和同步任务层如图[3]，通过"生产者与消费者"模式通过消息通信。理解这个模式的关键点是理解同步任务是活动模型。因此他们调用读写会引起阻塞，在任何时候都取决于他们的协议。如果数据还不可用，这个活动任务会进入睡眠，直到数据达到。反之，异步层的任务是被动对象，被动对象会触发来自外部事件源的通知或者中断。  

## 总结  
`Half Sync/Half Async`模式有以下几种好处：  
  * 高级任务编程模型简单，因为他们屏蔽了低级异步I/O。复杂并发模型，信号中断处理，计时器分发委托给异步任务层。异步任务层负责处理低级任务的细节，异步I/O编程模型（信号中断处理）。异步层同时也调度具体的硬件组件（如：DMA，内存管理和设备寄存器）。  
  * 同步方案在每一层都低耦合。因此每层不需要使用相同的并发控制策略。例如，在单线程的BSD UNIX内核，异步任务层通过低级任务机制（如，升降CPU的中断级别）实现并发控制，相反处于同步任务层的用户态，通过高级同步构造（如：信号量，消息队列，竞争资源，锁记录）实现并发控制。  
  * 内部层通信通过同一个端，因为所有的交互都由队列层调度。队列层缓冲的消息会被发送到同步和异步任务两层。这样就消除了锁定和序列化的复杂度，不管是同步还是异步任务层，都可以直接的访问他们自己的内存。  
  * 多处理器改善性能。使用同步I/O模型可以简化编程模型，并且在多处理器上会有性能提升。例如：持续时间长的数据传输（如：从数据库下载较大的医疗方面的图片）可以通过同步I/O模型，简便并高效的处理。一个处理器可以分配给传输数据的线程，促使相关联的CPU让整个传输操作享有CPU的指令和高速缓存。  
  `Half Sync/Half Async` 模式有以下几个缺点：  
  * 同步数据拷贝和上下文切换的开销可能会存在引起交叉的边界惩罚。这个开销通常产生于当同步、异步任务的队列层传输数据时。特别是，大多数操作系统适用`Half Sync/Half Async`模式，在用户态和内核态领域边界安置队列层。当发生边界交叉时，会有明显性能上的惩罚。例如：基于BSD UNIX的Socket层，占有大量比例基于TCP/IP的网络开销。  
  * 缺乏面向高级任务的异步I/O。由于异步I/O依赖系统接口的设计，因此可能高级任务不能利用提供了低级异步I/O设备。因此系统I/O结构可能会避免应用程序高效的利用硬件，尽管外部设备支持异步重叠计算和通信。  

# 实现  

# 1. 定义耗时长的任务并且使用同步I/O实现  
  许多系统的任务可以很容易的使用同步I/O实现。通常，耗时任务传输大的数据流或者执行数据库操作时可能会阻塞并长时间等待服务器响应。  
  实现这些耗时任务可以采用活动对象模型。因为活动对象有属于他们自己的运行栈和寄存器，当执行同步I/O时，他们会阻塞。实现活动对象机制，依赖一个切换上下文控制的方法。在底层，这意味着有空间存储当前线程状态的硬件（例如，所有值，包括线程的栈指针，都会存在线程对应的寄存器中）并且加载一个新线程的状态。这样足以实现一个不需要保护内存的非抢占式线程机制。"用户态线程"包通常提供了这样的功能。  
  但是，需要依赖更多多任务操作系统的特性，将活跃对象模型健壮的线程化和进程化。在这个案例中，每一个线程控制都有属于自己的地址空间，这些地址空间会被处理器的*内存管理单元*（MMU）管理。当切换之间的线程时，新的进程地址空间信息必须加载到MMU中。也可能还需要缓存刷新，特别是某种类型的虚拟地址缓存。除了地址空间，操作系统的进程通常有"用户标识"，这样操作系统才知道这个进程的访问权限以及有多少资源可以使用。  
  为了避免单个进程无止尽的霸占系统，因此变有了抢占的方式。抢占通常由计时器完成。计时器会定期地（例如：0.01秒）生成一个时钟中断信号。在这个中断期间操作系统会查看当前执行的进程是否需要被抢占。如果需要，它会保存这个进程的状态并且加载下一个进程的状态执行。当中断信号返回，那么新进程将开始运行。  

# 2. 定义耗时短的任务并且使用异步I/O实现  
  系统中的某个任务不能长期阻塞住。通常这些任务会使用耗时短且通过与外部事件源交互实现（例如图形界面、中断信号驱动的硬件网络接口）。提高性能并且确保响应时间，这些事件源必须无阻赛的提供服务。  
  实现这些耗时短的任务使用响应式，被动对象模型。被动对象会借助来自任何地方的线程控制（例如：调用者、独立的中断栈）。因此，这些任务必须使用异步I/O因为它们不会长时间阻塞。主要的动机是不会阻塞，确保充足的时机响应别的任务。（例如：优先级高的硬件中断，时钟计时器）。  
  这里有几种方式开发一个结构不错的异步I/O框架：  
  * 使用Reactor模式多路分解事件 - Reactor模式调度单个事件循环线程 - 该线程支持多路分解和分发多个任务管理者，支持并发地触发多个事件。这个模式将简单的一个单线程事件循环模型和基于面向对象编程扩展模式相互组合。Reactor模式序列化事件处理在一个进程或者一个线程里并且它通常不需要更复杂的线程、同步或者加锁。  
  Reactor可以通过中断执行同步和异步事件源实现。Reactor会提供一个异步的事件处理，因此这个事件处理不会阻塞不会妨碍到响应其他事件源。  
  * 实现多级别中断方案 - 这些实现允许非时间关键被高优先级任务处理（例如：硬件终端），当有高优先级事件时必须提前执行。异步层的数据结构必须被保护（例如：通过提高处理的优先级或者使用信号量）避免中断处理器同时被访问从而破坏共享状态。  
  例如，在操作系统内核中，对多级中断方案的需求受到硬件中断服务时间的强烈影响。如果这个时间可以显着降低，则在硬件中断级别执行所有处理可能会更有效，以避免额外的软件中断的开销。 TCP / IP的实现降低了入站分组协议处理开销，使得两级中断方案的成本支配整个分组处理时间。  
  
# 3. 实现队列层  
  队列层提供了同步点用于缓冲交换同步任务层和异步任务层之间的消息。以下的几个论点会围绕设计队列层的寻址：  
  * 并发控制 - 当一个异步任务层和同步任务层并发执行时（既可能是多个CPU决定也可能是中断决定）有必要确保并发访问共享队列的状态是会避免资源竞争的。因此队列层通常会使用并发控制机制实现，例如信号量，互斥，竞争资源。这些机制会确保信息可以被队列层插入和删除并且不被内部数据破坏队列内数据的结构。  
  * 层和层之间的控制流 - 系统不能无限制的将很多资源奉献给队列层的消息缓冲区。因为同步任务层和异步任务层的数据传输是有必要调节的。例如：层和层之间的控制流程应当避免同步任务因为消息过多淹没异步层，影响网络接口的传输。  
    同步层任务会阻塞，因此当同步任务正在处理等待更多的数据时，正常的流程控制方案是会让它进入睡眠。当异步任务层在离开队列时，下面的某个级别的同步任务会被继续唤醒。反之，异步任务不会阻塞，因此，如果它们产生过多的数据，则公共流控制策略将使排队层丢弃消息, 因此，如果它们产
生的数据的量过多共用流控制策略是有排队层丢弃消息。当消息有关联的依赖面向可靠连接的网络协议时，它的发起者最终会超时，并且重发。  
  * 数据拷贝开销 - 一些系统（例如：BSD UNIX）会在用户态和内核态之间存放一个队列层。通常的解耦方式是通过拷贝它们之前的消息。然而，这样会增加系统总线和内存的读取，当有大消息的传递时，会明显地降低性能。  
    一种方式是减少数据拷贝的，分配一块内存用于共享在同步和异步任务层。这样允许两个层之间数据直接交换，不需要通过拷贝到队列层。例如，提供一个I/O子系统，通过轮训中断信号来改善处理连续的媒体I/O流。这种方法还提供了一个缓冲管理系统，允许高效的分页重新映射同时共享内存机制可以跨用户态，内核，以及设备。

# 参考资料  
    [PLoP-95.pdf](www.cs.wustl.edu/~schmidt/PDF/PLoP-95.pdf) 