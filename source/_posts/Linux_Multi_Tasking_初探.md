title: Linux中的多任务
date: 2016-04-11 22:56:18
tags:
  - linux
  - computer multitasking
---

#### 什么是computer multitasking?
`computer multitasking`俗称多任务处理。是指计算机同时处理多个任务的能力。
多任务的实现方式，一般是运行第一个任务的一部分代码，保存上下文，再执行第二个任务，保存上下文。
然后恢复第一个程序的上下文继续执行……


#### Linux里的Process  

##### `Process`俗称进程。是一个装载程序代码的容器。
进程还包括了一系列资源：`打开文件`、`待定的信号量`、`内部的内核数据`、
`处理器状态`、`内存地址空间`、`线程`、`数据区块：包含了很多全局变量`  

##### 如何通过`Processes`(多个进程)实现`computer multitasking`?

首先我们看下进程的调度策略：
  一种方案是`Cooperative multitasking`(协作式多任务)
通过`霸占`当前CPU分配的时间，由进程自己决定是否爽够了把时间让给别的进程工作。
当进程爽够了的时候，它会告知`kernel`把时间让给下一个进程，`kernel`会提前处理
这样的缺点是，一个进程如果一直霸占会导致`kernel`卡顿，优点是进程的调度时间都是预期的（不会被强制终止）

  还有一种方案是`Preemption multitasking`(抢占式多任务)
这种方案目前的*nix和windows系统都是采用这套设计。
通过`kernel`来作进程调度，`kernel`有自己的一套规则，看着不顺眼的进程就把它的工作挂起。
这样的缺点是，提高了编写进程任务的复杂度，优点是可以通过抢占争取更多的时间在有效的工作任务上。

如何实现多任务？为什么要有多任务？
当执行一个大程序的时候，它有一个非常大的任务，又追求处理速度。那么可以把大任务分成几个不同的子任务。
分配给不同的进程。那么多个进程如何一起处理一个大任务呢？可以通过共享上下文的办法。
通过`IPC`（进程调用）传递之间的上下文。
当要同时执行多个程序的时候也需要多任务。可以把多个程序分配给多个不同的进程。
当进程挂起的时候保存自己的上下文，当进程又获得重生的时候，载入保存的上下文继续工作。


##### `Thread`俗称线程。是进程的一部分。
Linux里线程也是进程的一种实现。进程的实现是从虚拟内存里分配一部分空间给当前进程。并且每个进程的上下文完全独立。
然而线程是由进程分配。一个进程里不同线程共享当前进程的上下文。
线程依赖进程。当进程被挂起，那么线程任务也全部挂起。（其实线程就是进程里的小生命）

#### 进程调度的初探

进程的调度可以被分为`I/O-bound`(IO密集型)和`Processor-bound`（处理器密集型）
`I/O-bound`负责处理进程里的IO请求(IO请求的提交以及等待IO执行结果)
`Processor-bound`则是只负责执行进程里读取`text section`里的代码

所以你发现进程被抢占了那是因为`I/O-bound`处理了一个阻塞的请求。
当进程在工作的时候，那是`Processor-bound`在执行代码。


#### 参考资料
  <Linux Kernel Development 3rd Edition>
